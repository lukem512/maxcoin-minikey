<!DOCTYPE html>
<html>
	<head>
		<title>MaxCoin Cryptobullion Redemption Tool</title>
		<meta charset="utf-8">

		<!-- Bootstrap -->
		<link rel="stylesheet" href="css/bootstrap.min.css">
		<!-- End of Bootstrap -->

		<!-- Cryptojs hashing functions -->
		<script src="js/cryptojs-v3/sha256.js"></script>
		<script src="js/cryptojs-v3/ripemd160.js"></script>
		<script src="js/cryptojs-v3/sha3.js"></script>
		<script src="js/cryptojs-v3/lib-typedarrays.js"></script>
		<!-- End of cryptojs hashing functions -->

		<!-- EC keypair generation -->
		<script src="js/jsrsasign/jsrsasign-latest-all-min.js"></script>
		<!-- End of EC keypair generation -->

		<!-- Base58 encoding -->
		<script src="js/cryptocoinjs/bs58.js"></script>
		<!-- End of base58 encoding -->

		<!-- Address generation functions -->
		<!-- Luke Mitchell, July 2014 -->
		<script>
			var hash_keccak = function(s) {
				return CryptoJS.SHA3(s, {  outputLength: 256, asBytes: true });
			}

			var hash_sha256 = function(s) { 
				return CryptoJS.SHA256(s, { asBytes: true });
			}

			var hash_ripemd160 = function(s) {
				return CryptoJS.RIPEMD160(s, { asBytes: true });
			}

			var create_keypair = function() {
				var keypair = KEYUTIL.generateKeypair("EC", "secp256r1");
				return {prvKey: keypair.prvKeyObj.prvKeyHex, pubKey: keypair.pubKeyObj.pubKeyHex};
			}

			function wordArrayToByteArray(wordArray) {
				// Shortcuts
		        var words = wordArray.words;
		        var sigBytes = wordArray.sigBytes;

		        // Convert
		        var u8 = new Uint8Array(sigBytes);
		        for (var i = 0; i < sigBytes; i++) {
		            var byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
		            u8[i]=byte;
		        }

		        return u8;
			}

			var prvKey_to_WIF = function(prvKey) {
				// encode for CryptoJS
				var baby = CryptoJS.enc.Hex.parse(prvKey);

				// add 0x80 to beginning
				var version = CryptoJS.enc.Hex.parse('80');
				var child = version.concat(baby);

				// hash the extended key
				var teenager = hash_keccak(child);

				// take first 4 bytes of second hash as checksum
				var checksum = CryptoJS.lib.WordArray.create(teenager.words.slice(0, 4), 4);

				// add checksum to end of extended key
				var adult = child.concat(checksum);

				// convert to byte array, for base58
				var bytes = wordArrayToByteArray(adult);

				console.log(bytes);
				console.log(bs58_encode(bytes));

				// base58 encode
				return bs58_encode(bytes);
			}

			var create_address = function(pubkey) {
				// encode for CryptoJS
				var key = CryptoJS.enc.Hex.parse(pubkey);
			    	
				// hash public key
			    // using RIPEMD160(SHA256(pubkey))	
				var baby = hash_sha256(key);
				var child = hash_ripemd160(baby);

				// add version/network byte (base58 'm')
				var version = CryptoJS.enc.Hex.parse('6e');
				version.concat(child);
				var teenager = version;;

				// hash this using Keccak
				var adult = hash_keccak(teenager);

				// take 4 bytes as checksum
				// append these to the end of the string
				var checksum = CryptoJS.lib.WordArray.create(adult.words.slice(0, 4), 4);
				var pensioner = teenager;
				pensioner.concat(checksum);

				// convert to byte array, for base58
				var bytes = wordArrayToByteArray(pensioner);

				// base58 encode the address
				return bs58_encode(bytes);
			};

			var generate_new_address = function() {
				// Create a public/private keypair
				var keypair = create_keypair();

				var wifKey = prvKey_to_WIF(keypair.prvKey);
				console.log(wifKey);

				// Create a MaxCoin address from this keypair
				var address = create_address(keypair.pubKey);
			}

			var valid_mini = function(mini) {
				var waHash = hash_sha256(mini + "?");
				var hash = waHash.toString(CryptoJS.enc.Hex);
				return (hash[0] == 0x0);
			}

			var convert_and_display = function() {
				var mini = document.getElementById('minikey').value;

				// Check that the minikey is valid
				if (!valid_mini(mini)) {
					alert("Error: key provided is not a valid Minikey");
					return;
				}

				var priv = hash_sha256(mini);
				var wif = prvKey_to_WIF(priv.toString(CryptoJS.enc.Hex));

				// TODO: this could be quite difficult...
				// MaxCoin uses secp256r1
				// We need to do privKey_to_pubKey
				// var a = version + ripemd160(sha256(pubKey))
				// var b = a + keccak(a)[:4]
				// var address = base58(b)

				document.getElementById("wifkey").innerHTML = wif;
				// document.getElementById("address").innerHTML = address;
			}
		</script>
		<!-- End of address generation functions -->
	</head>
	<body>
		<div class="container">
			<div class="page-header">
				<h1 class="text-muted">MaxCoin Cryptobullion Redemption Tool</h1>
				<p class="lead">This tool provides the ability to convert Minikeys, found on your cryptobullion, to Wallet Import Format keys that will be accepted by the MaxCoin wallet.</p>
			</div>

			<div class="row well">
				<div class="col-md-4">
					<span class="text-muted" style="font-size:0.8em;display:block;">Minikey</span>
					<form class="form form-inline" role="form">
						<input type="text" id="minikey" class="form-control" value="" placeholder="S6c56bnXQiBjk9mqSYE7ykVQ7NzrRy"></input>
						<input type="button" class="btn btn-default" class="form-control" value="Convert" onclick="convert_and_display()"></input>
					</form>
				</div>

				<div class="col-md-2">
					<p style="font-size:5em;font-weight:bolder;">&rlhar;</p>
				</div>

				<div class="col-md-6">
					<!-- <div id="address-container">
						<span class="text-muted" style="font-size:0.8em;display:block;">Address</span>
						<span id="address" style="font-size:1em;font-weight:bold;font-family:Courier,monospace"></span>
					</div>

					<br /> -->

					<div id="wif-container">
						<span class="text-muted" style="font-size:0.8em;display:block;">Wallet Import Format (WIF)</span>
						<span id="wifkey" style="font-size:1em;font-weight:bold;font-family:Courier,monospace"></span>
					</div>
				</div>

			</div>
			<footer class="footer">
		    	<p>Created by <a href="https://twitter.com/LukeCrypto">LukeCrypto</a> for Mike Murphy &bullet; 2015 &bullet; MaxCoin Cryptobullion Project</p>
		    </footer>
		</div>
	</body>
</html>